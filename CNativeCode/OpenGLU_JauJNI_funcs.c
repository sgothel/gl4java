/* WARNING ! WARNING *** THIS FILE IS GENERATED BY C2J !!!

   DO NOT MAKE ANY CHANGES *** MAKE CHANGES IN THE SKELETON FILES !!!
*/


/*
 * Leo Chan -- 1995
 *
 * This C file takes care of all the native implementation for the
 * OpenGL utility commands
 * ---------------
 *
 * Sven Goethel
 *
 * September 1997
 */


/*--------------------------------------------------------------------------
 * here on in is just regular apple pie C
 */

#include "OpenGL_misc.h"

#include "gl4java_GLUFuncJauJNI.h"

#include "GLCallbackHelperJNI.h"
#include "GLUCallbackJNI.h"
#include "jnitools.h"

/**
 * herein lies the native JAVA methods for the OpenGL functions.  
 */

static const char _glu_n_a_string[] = "GLU-String not avaiable !";

JNIEXPORT jstring JNICALL
Java_gl4java_GLUFuncJauJNI_gluErrorString ( JNIEnv *env, jobject obj,
	                                    jint errorCode ) 
{
    const char *tmpString=0;

    tmpString = gluErrorString ( /* jint */ errorCode );
    if(tmpString==NULL)
    	tmpString=_glu_n_a_string;

    return (*env)->NewStringUTF(env, tmpString);
}

JNIEXPORT jstring JNICALL
Java_gl4java_GLUFuncJauJNI_gluGetString ( JNIEnv *env, jobject obj,
	                                  jint name ) 
{
    const char *tmpString=0;

    tmpString = gluGetString ( /* jint */ name);
    if(tmpString==NULL)
    	tmpString=_glu_n_a_string;

    return (*env)->NewStringUTF(env, tmpString);   
}

static const char * _glu_lib_vendor_="Jausoft - Sven Goethel Software Development";
static const char * _glu_lib_version_="2.5.2.0";

JNIEXPORT jstring JNICALL
Java_gl4java_GLUFuncJauJNI_getNativeVendor ( JNIEnv *env, jobject obj )
{
    return (*env)->NewStringUTF(env, _glu_lib_vendor_);   
}

JNIEXPORT jstring JNICALL
Java_gl4java_GLUFuncJauJNI_getNativeVersion ( JNIEnv *env, jobject obj )
{
    return (*env)->NewStringUTF(env, _glu_lib_version_);   
}

static void _AddCallbackNode(JNIEnv *env,
	                          jlong qnt_obj, jint which,
			          jobject methodClassInstance, 
			          jstring methodName, 
				  jstring signature,
				  jint arrayLen1,
				  jint arrayLen2,
				  jint arrayLen3,
				  jint arrayLen4,
				  jint arrayLen5)
{
	char * strMethodName = jnitoolsGetJavaString(env, methodName);
	char * strSignature = jnitoolsGetJavaString(env, signature);
	jlong glx=0;

	glx = GetCurrentGLContext();

	AddCallbackNode(env, methodClassInstance, strMethodName, strSignature,
			arrayLen1, arrayLen2, arrayLen3,
			arrayLen4, arrayLen5,
			(void *)((PointerHolder)qnt_obj), which, glx);
	free(strMethodName);
	free(strSignature);
}
                  

JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluQuadricCallback( JNIEnv *env, jobject obj,
	                          jlong qobj, jint which,
			          jobject methodClassInstance, 
			          jstring methodName, 
				  jstring signature)
{
	switch(which)
	{
		case GLU_ERROR:
			gluQuadricCallback((void *)((PointerHolder)qobj), 
			                   which, cbf_GLU_ERROR );
			break;
		default:
		    jnitoolsThrowByName(env, "java/lang/IllegalArgumentException", "Wrong Callback-Function type (\"which\") !");
		    return;
	}
	_AddCallbackNode(env, 
			 qobj, which, methodClassInstance, methodName, 
			  signature, 
			  0, 0, 0, 0, 0);
}


JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluNurbsCallback( JNIEnv *env, jobject obj,
	                          jlong nobj, jint which,
			          jobject methodClassInstance, 
			          jstring methodName, 
				  jstring signature)
{
	switch(which)
	{
		case GLU_ERROR:
			gluNurbsCallback((void *)((PointerHolder)nobj), which, 
				         cbf_GLU_ERROR );
			break;
		default:
		    jnitoolsThrowByName(env, "java/lang/IllegalArgumentException", "Wrong Callback-Function type (\"which\") !");
		    return;
	}
	_AddCallbackNode(env,
			 nobj, which, methodClassInstance, methodName, 
			  signature, 
			  0, 0, 0, 0, 0);
}

JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluTessCallback( JNIEnv *env, jobject obj,
	                          jlong tobj, jint which,
			          jobject methodClassInstance, 
			          jstring methodName, 
				  jstring signature,
				  jint arrayLen1,
				  jint arrayLen2,
				  jint arrayLen3,
				  jint arrayLen4,
				  jint arrayLen5)
{
	switch(which)
	{
		case GLU_TESS_BEGIN:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_BEGIN );
			break;
		case GLU_TESS_BEGIN_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_BEGIN_DATA );
			break;
		case GLU_TESS_EDGE_FLAG:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_EDGE_FLAG );
			break;
		case GLU_TESS_EDGE_FLAG_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_EDGE_FLAG_DATA );
			break;
		case GLU_TESS_VERTEX:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_VERTEX );
			break;
		case GLU_TESS_VERTEX_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_VERTEX_DATA );
			break;
		case GLU_TESS_END:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_END );
			break;
		case GLU_TESS_END_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_END_DATA );
			break;
		case GLU_TESS_ERROR:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_ERROR );
			break;
		case GLU_TESS_ERROR_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_ERROR_DATA );
			break;
		case GLU_TESS_COMBINE:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_COMBINE );
			break;
		case GLU_TESS_COMBINE_DATA:
			gluTessCallback((GLUtesselator *)((PointerHolder)tobj), 
			                which, 
				        cbf_GLU_TESS_COMBINE_DATA );
			break;
		default:
		    jnitoolsThrowByName(env, "java/lang/IllegalArgumentException", "Wrong Callback-Function type (\"which\") !");
		    return;
	}
	_AddCallbackNode(env,
			  tobj, which, methodClassInstance, methodName, 
			  signature, 
			  arrayLen1, arrayLen2, arrayLen3,
			  arrayLen4, arrayLen5);
}

JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluDeleteQuadric( JNIEnv *env, jobject obj,
					     jlong qobj )
{
	gluDeleteQuadric((void *)((PointerHolder)qobj));
	RemoveCallbackNodes((void *)((PointerHolder)qobj));
}

JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluDeleteNurbsRenderer( JNIEnv *env, jobject obj,
						   jlong nobj )
{
	gluDeleteNurbsRenderer((void *)((PointerHolder)nobj));
	RemoveCallbackNodes((void *)((PointerHolder)nobj));
}

JNIEXPORT void JNICALL
Java_gl4java_GLUFuncJauJNI_gluDeleteTess( JNIEnv *env, jobject obj,
					  jlong tobj )
{
	gluDeleteTess((GLUtesselator *)((PointerHolder)tobj));
	RemoveCallbackNodes((void *)((PointerHolder)tobj));
}

JNIEXPORT jlong JNICALL
Java_gl4java_GLUFuncJauJNI_gluNewQuadric( JNIEnv *env, jobject obj)
{
	return (jlong)((PointerHolder)gluNewQuadric());
}

JNIEXPORT jlong JNICALL
Java_gl4java_GLUFuncJauJNI_gluNewNurbsRenderer( JNIEnv *env, jobject obj)
{
	return (jlong)((PointerHolder)gluNewNurbsRenderer());
}

JNIEXPORT jlong JNICALL
Java_gl4java_GLUFuncJauJNI_gluNewTess( JNIEnv *env, jobject obj)
{
	return (jlong)((PointerHolder)gluNewTess());
}

/**
 * C2J Parser Version 1.5 Beta
 * Jausoft - Sven Goethel Software Development
 * Reading from file: glu-proto-auto.orig.h . . .
 * Destination-Class: gl4java_GLUFuncJauJNI ! 
 */

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluLookAt ( GLdouble eyex , GLdouble eyey , GLdouble eyez , GLdouble centerx , GLdouble centery , GLdouble centerz , GLdouble upx , GLdouble upy , GLdouble upz ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluLookAt (
		JNIEnv *env, jobject obj,
		jdouble eyex,
		jdouble eyey,
		jdouble eyez,
		jdouble centerx,
		jdouble centery,
		jdouble centerz,
		jdouble upx,
		jdouble upy,
		jdouble upz)
	{

		gluLookAt (
			(GLdouble) eyex,
			(GLdouble) eyey,
			(GLdouble) eyez,
			(GLdouble) centerx,
			(GLdouble) centery,
			(GLdouble) centerz,
			(GLdouble) upx,
			(GLdouble) upy,
			(GLdouble) upz
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluOrtho2D ( GLdouble left , GLdouble right , GLdouble bottom , GLdouble top ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluOrtho2D (
		JNIEnv *env, jobject obj,
		jdouble left,
		jdouble right,
		jdouble bottom,
		jdouble top)
	{

		gluOrtho2D (
			(GLdouble) left,
			(GLdouble) right,
			(GLdouble) bottom,
			(GLdouble) top
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluPerspective ( GLdouble fovy , GLdouble aspect , GLdouble zNear , GLdouble zFar ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluPerspective (
		JNIEnv *env, jobject obj,
		jdouble fovy,
		jdouble aspect,
		jdouble zNear,
		jdouble zFar)
	{

		gluPerspective (
			(GLdouble) fovy,
			(GLdouble) aspect,
			(GLdouble) zNear,
			(GLdouble) zFar
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluPickMatrix ( GLdouble x , GLdouble y , GLdouble width , GLdouble height , GLint * viewport ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluPickMatrix (
		JNIEnv *env, jobject obj,
		jdouble x,
		jdouble y,
		jdouble width,
		jdouble height,
		jintArray viewport)
	{
		jboolean isCopiedArray4 = JNI_FALSE;
		jint *ptr4 = NULL;

		if(viewport!=NULL)
		{
			ptr4 = (*env)->GetIntArrayElements(env, viewport, &isCopiedArray4);
		}
		gluPickMatrix (
			(GLdouble) x,
			(GLdouble) y,
			(GLdouble) width,
			(GLdouble) height,
			(GLint *) ptr4
		);

		if(viewport!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  viewport, ptr4, (isCopiedArray4 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern GLint gluProject ( GLdouble objx , GLdouble objy , GLdouble objz , const GLdouble modelMatrix [ 16 ] , const GLdouble projMatrix [ 16 ] , const GLint viewport [ 4 ] , GLdouble * winx , GLdouble * winy , GLdouble * winz ) ;
 * </pre> 
 */
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluProject (
		JNIEnv *env, jobject obj,
		jdouble objx,
		jdouble objy,
		jdouble objz,
		jdoubleArray modelMatrix,
		jdoubleArray projMatrix,
		jintArray viewport,
		jdoubleArray winx,
		jdoubleArray winy,
		jdoubleArray winz)
	{
		jint ret;

		jdouble *ptr3 = NULL;
		jdouble *ptr4 = NULL;
		jint *ptr5 = NULL;
		jboolean isCopiedArray6 = JNI_FALSE;
		jdouble *ptr6 = NULL;
		jboolean isCopiedArray7 = JNI_FALSE;
		jdouble *ptr7 = NULL;
		jboolean isCopiedArray8 = JNI_FALSE;
		jdouble *ptr8 = NULL;

		if(modelMatrix!=NULL)
		{
			ptr3 = (*env)->GetDoubleArrayElements(env, modelMatrix, 0);
		}
		if(projMatrix!=NULL)
		{
			ptr4 = (*env)->GetDoubleArrayElements(env, projMatrix, 0);
		}
		if(viewport!=NULL)
		{
			ptr5 = (*env)->GetIntArrayElements(env, viewport, 0);
		}
		if(winx!=NULL)
		{
			ptr6 = (*env)->GetDoubleArrayElements(env, winx, &isCopiedArray6);
		}
		if(winy!=NULL)
		{
			ptr7 = (*env)->GetDoubleArrayElements(env, winy, &isCopiedArray7);
		}
		if(winz!=NULL)
		{
			ptr8 = (*env)->GetDoubleArrayElements(env, winz, &isCopiedArray8);
		}
		ret = (jint) gluProject (
			(GLdouble) objx,
			(GLdouble) objy,
			(GLdouble) objz,
			(const GLdouble *) ptr3,
			(const GLdouble *) ptr4,
			(const GLint *) ptr5,
			(GLdouble *) ptr6,
			(GLdouble *) ptr7,
			(GLdouble *) ptr8
		);

		if(modelMatrix!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  modelMatrix, ptr3, JNI_ABORT);
		}
		if(projMatrix!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  projMatrix, ptr4, JNI_ABORT);
		}
		if(viewport!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  viewport, ptr5, JNI_ABORT);
		}
		if(winx!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  winx, ptr6, (isCopiedArray6 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(winy!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  winy, ptr7, (isCopiedArray7 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(winz!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  winz, ptr8, (isCopiedArray8 == JNI_TRUE)?0:JNI_ABORT);
		}
		return ret;
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern GLint gluUnProject ( GLdouble winx , GLdouble winy , GLdouble winz , const GLdouble modelMatrix [ 16 ] , const GLdouble projMatrix [ 16 ] , const GLint viewport [ 4 ] , GLdouble * objx , GLdouble * objy , GLdouble * objz ) ;
 * </pre> 
 */
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluUnProject (
		JNIEnv *env, jobject obj,
		jdouble winx,
		jdouble winy,
		jdouble winz,
		jdoubleArray modelMatrix,
		jdoubleArray projMatrix,
		jintArray viewport,
		jdoubleArray objx,
		jdoubleArray objy,
		jdoubleArray objz)
	{
		jint ret;

		jdouble *ptr3 = NULL;
		jdouble *ptr4 = NULL;
		jint *ptr5 = NULL;
		jboolean isCopiedArray6 = JNI_FALSE;
		jdouble *ptr6 = NULL;
		jboolean isCopiedArray7 = JNI_FALSE;
		jdouble *ptr7 = NULL;
		jboolean isCopiedArray8 = JNI_FALSE;
		jdouble *ptr8 = NULL;

		if(modelMatrix!=NULL)
		{
			ptr3 = (*env)->GetDoubleArrayElements(env, modelMatrix, 0);
		}
		if(projMatrix!=NULL)
		{
			ptr4 = (*env)->GetDoubleArrayElements(env, projMatrix, 0);
		}
		if(viewport!=NULL)
		{
			ptr5 = (*env)->GetIntArrayElements(env, viewport, 0);
		}
		if(objx!=NULL)
		{
			ptr6 = (*env)->GetDoubleArrayElements(env, objx, &isCopiedArray6);
		}
		if(objy!=NULL)
		{
			ptr7 = (*env)->GetDoubleArrayElements(env, objy, &isCopiedArray7);
		}
		if(objz!=NULL)
		{
			ptr8 = (*env)->GetDoubleArrayElements(env, objz, &isCopiedArray8);
		}
		ret = (jint) gluUnProject (
			(GLdouble) winx,
			(GLdouble) winy,
			(GLdouble) winz,
			(const GLdouble *) ptr3,
			(const GLdouble *) ptr4,
			(const GLint *) ptr5,
			(GLdouble *) ptr6,
			(GLdouble *) ptr7,
			(GLdouble *) ptr8
		);

		if(modelMatrix!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  modelMatrix, ptr3, JNI_ABORT);
		}
		if(projMatrix!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  projMatrix, ptr4, JNI_ABORT);
		}
		if(viewport!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  viewport, ptr5, JNI_ABORT);
		}
		if(objx!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  objx, ptr6, (isCopiedArray6 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(objy!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  objy, ptr7, (isCopiedArray7 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(objz!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  objz, ptr8, (isCopiedArray8 == JNI_TRUE)?0:JNI_ABORT);
		}
		return ret;
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern GLint gluScaleImage ( GLenum format , GLsizei widthin , GLsizei heightin , GLenum typein , const char * datain , GLsizei widthout , GLsizei heightout , GLenum typeout , char * dataout ) ;
 * </pre> 
 */
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluScaleImage (
		JNIEnv *env, jobject obj,
		jint format,
		jint widthin,
		jint heightin,
		jint typein,
		jbyteArray datain,
		jint widthout,
		jint heightout,
		jint typeout,
		jbyteArray dataout)
	{
		jint ret;

		jbyte *ptr4 = NULL;
		jboolean isCopiedArray8 = JNI_FALSE;
		jbyte *ptr8 = NULL;

		if(datain!=NULL)
		{
			ptr4 = (*env)->GetByteArrayElements(env, datain, 0);
		}
		if(dataout!=NULL)
		{
			ptr8 = (*env)->GetByteArrayElements(env, dataout, &isCopiedArray8);
		}
		ret = (jint) gluScaleImage (
			(GLenum) format,
			(GLsizei) widthin,
			(GLsizei) heightin,
			(GLenum) typein,
			(const char *) ptr4,
			(GLsizei) widthout,
			(GLsizei) heightout,
			(GLenum) typeout,
			(char *) ptr8
		);

		if(datain!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  datain, ptr4, JNI_ABORT);
		}
		if(dataout!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  dataout, ptr8, (isCopiedArray8 == JNI_TRUE)?0:JNI_ABORT);
		}
		return ret;
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern GLint gluBuild1DMipmaps ( GLenum target , GLint components , GLint width , GLenum format , GLenum type , const void * data ) ;
 * </pre> 
 */
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3B (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jbyteArray data)
	{
		jint ret;

		jbyte *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetByteArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3S (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jshortArray data)
	{
		jint ret;

		jshort *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetShortArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseShortArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3I (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jintArray data)
	{
		jint ret;

		jint *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetIntArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3F (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jfloatArray data)
	{
		jint ret;

		jfloat *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetFloatArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3D (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jdoubleArray data)
	{
		jint ret;

		jdouble *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetDoubleArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3Z (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jbooleanArray data)
	{
		jint ret;

		jboolean *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetBooleanArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseBooleanArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild1DMipmaps__IIIII_3J (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint format,
		jint type,
		jlongArray data)
	{
		jint ret;

		jlong *ptr5 = NULL;

		if(data!=NULL)
		{
			ptr5 = (*env)->GetLongArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild1DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr5
		);

		if(data!=NULL)
		{
			(*env)->ReleaseLongArrayElements(env,  data, ptr5, JNI_ABORT);
		}
		return ret;
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern GLint gluBuild2DMipmaps ( GLenum target , GLint components , GLint width , GLint height , GLenum format , GLenum type , const void * data ) ;
 * </pre> 
 */
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3B (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jbyteArray data)
	{
		jint ret;

		jbyte *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetByteArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3S (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jshortArray data)
	{
		jint ret;

		jshort *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetShortArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseShortArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3I (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jintArray data)
	{
		jint ret;

		jint *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetIntArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3F (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jfloatArray data)
	{
		jint ret;

		jfloat *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetFloatArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3D (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jdoubleArray data)
	{
		jint ret;

		jdouble *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetDoubleArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3Z (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jbooleanArray data)
	{
		jint ret;

		jboolean *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetBooleanArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseBooleanArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}
	JNIEXPORT jint JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBuild2DMipmaps__IIIIII_3J (
		JNIEnv *env, jobject obj,
		jint target,
		jint components,
		jint width,
		jint height,
		jint format,
		jint type,
		jlongArray data)
	{
		jint ret;

		jlong *ptr6 = NULL;

		if(data!=NULL)
		{
			ptr6 = (*env)->GetLongArrayElements(env, data, 0);
		}
		ret = (jint) gluBuild2DMipmaps (
			(GLenum) target,
			(GLint) components,
			(GLint) width,
			(GLint) height,
			(GLenum) format,
			(GLenum) type,
			(const void *) ptr6
		);

		if(data!=NULL)
		{
			(*env)->ReleaseLongArrayElements(env,  data, ptr6, JNI_ABORT);
		}
		return ret;
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluQuadricDrawStyle ( GLUquadricObj * quadObject , GLenum drawStyle ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluQuadricDrawStyle (
		JNIEnv *env, jobject obj,
		jlong quadObject,
		jint drawStyle)
	{

		gluQuadricDrawStyle (
			(GLUquadricObj *) (PointerHolder) quadObject,
			(GLenum) drawStyle
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluQuadricOrientation ( GLUquadricObj * quadObject , GLenum orientation ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluQuadricOrientation (
		JNIEnv *env, jobject obj,
		jlong quadObject,
		jint orientation)
	{

		gluQuadricOrientation (
			(GLUquadricObj *) (PointerHolder) quadObject,
			(GLenum) orientation
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluQuadricNormals ( GLUquadricObj * quadObject , GLenum normals ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluQuadricNormals (
		JNIEnv *env, jobject obj,
		jlong quadObject,
		jint normals)
	{

		gluQuadricNormals (
			(GLUquadricObj *) (PointerHolder) quadObject,
			(GLenum) normals
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluQuadricTexture ( GLUquadricObj * quadObject , GLboolean textureCoords ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluQuadricTexture (
		JNIEnv *env, jobject obj,
		jlong quadObject,
		jboolean textureCoords)
	{

		gluQuadricTexture (
			(GLUquadricObj *) (PointerHolder) quadObject,
			(GLboolean) textureCoords
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluCylinder ( GLUquadricObj * qobj , GLdouble baseRadius , GLdouble topRadius , GLdouble height , GLint slices , GLint stacks ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluCylinder (
		JNIEnv *env, jobject obj,
		jlong qobj,
		jdouble baseRadius,
		jdouble topRadius,
		jdouble height,
		jint slices,
		jint stacks)
	{

		gluCylinder (
			(GLUquadricObj *) (PointerHolder) qobj,
			(GLdouble) baseRadius,
			(GLdouble) topRadius,
			(GLdouble) height,
			(GLint) slices,
			(GLint) stacks
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluSphere ( GLUquadricObj * qobj , GLdouble radius , GLint slices , GLint stacks ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluSphere (
		JNIEnv *env, jobject obj,
		jlong qobj,
		jdouble radius,
		jint slices,
		jint stacks)
	{

		gluSphere (
			(GLUquadricObj *) (PointerHolder) qobj,
			(GLdouble) radius,
			(GLint) slices,
			(GLint) stacks
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluDisk ( GLUquadricObj * qobj , GLdouble innerRadius , GLdouble outerRadius , GLint slices , GLint loops ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluDisk (
		JNIEnv *env, jobject obj,
		jlong qobj,
		jdouble innerRadius,
		jdouble outerRadius,
		jint slices,
		jint loops)
	{

		gluDisk (
			(GLUquadricObj *) (PointerHolder) qobj,
			(GLdouble) innerRadius,
			(GLdouble) outerRadius,
			(GLint) slices,
			(GLint) loops
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluPartialDisk ( GLUquadricObj * qobj , GLdouble innerRadius , GLdouble outerRadius , GLint slices , GLint loops , GLdouble startAngle , GLdouble sweepAngle ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluPartialDisk (
		JNIEnv *env, jobject obj,
		jlong qobj,
		jdouble innerRadius,
		jdouble outerRadius,
		jint slices,
		jint loops,
		jdouble startAngle,
		jdouble sweepAngle)
	{

		gluPartialDisk (
			(GLUquadricObj *) (PointerHolder) qobj,
			(GLdouble) innerRadius,
			(GLdouble) outerRadius,
			(GLint) slices,
			(GLint) loops,
			(GLdouble) startAngle,
			(GLdouble) sweepAngle
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluLoadSamplingMatrices ( GLUnurbsObj * nobj , const GLfloat modelMatrix [ 16 ] , const GLfloat projMatrix [ 16 ] , const GLint viewport [ 4 ] ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluLoadSamplingMatrices (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jfloatArray modelMatrix,
		jfloatArray projMatrix,
		jintArray viewport)
	{
		jfloat *ptr1 = NULL;
		jfloat *ptr2 = NULL;
		jint *ptr3 = NULL;

		if(modelMatrix!=NULL)
		{
			ptr1 = (*env)->GetFloatArrayElements(env, modelMatrix, 0);
		}
		if(projMatrix!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, projMatrix, 0);
		}
		if(viewport!=NULL)
		{
			ptr3 = (*env)->GetIntArrayElements(env, viewport, 0);
		}
		gluLoadSamplingMatrices (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(const GLfloat *) ptr1,
			(const GLfloat *) ptr2,
			(const GLint *) ptr3
		);

		if(modelMatrix!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  modelMatrix, ptr1, JNI_ABORT);
		}
		if(projMatrix!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  projMatrix, ptr2, JNI_ABORT);
		}
		if(viewport!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  viewport, ptr3, JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluNurbsProperty ( GLUnurbsObj * nobj , GLenum property , GLfloat value ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluNurbsProperty (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jint property,
		jfloat value)
	{

		gluNurbsProperty (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(GLenum) property,
			(GLfloat) value
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluGetNurbsProperty ( GLUnurbsObj * nobj , GLenum property , GLfloat * value ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluGetNurbsProperty (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jint property,
		jfloatArray value)
	{
		jboolean isCopiedArray2 = JNI_FALSE;
		jfloat *ptr2 = NULL;

		if(value!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, value, &isCopiedArray2);
		}
		gluGetNurbsProperty (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(GLenum) property,
			(GLfloat *) ptr2
		);

		if(value!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  value, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluBeginCurve ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBeginCurve (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluBeginCurve (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluEndCurve ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluEndCurve (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluEndCurve (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluNurbsCurve ( GLUnurbsObj * nobj , GLint nknots , GLfloat * knot , GLint stride , GLfloat * ctlarray , GLint order , GLenum type ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluNurbsCurve (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jint nknots,
		jfloatArray knot,
		jint stride,
		jfloatArray ctlarray,
		jint order,
		jint type)
	{
		jboolean isCopiedArray2 = JNI_FALSE;
		jfloat *ptr2 = NULL;
		jboolean isCopiedArray4 = JNI_FALSE;
		jfloat *ptr4 = NULL;

		if(knot!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, knot, &isCopiedArray2);
		}
		if(ctlarray!=NULL)
		{
			ptr4 = (*env)->GetFloatArrayElements(env, ctlarray, &isCopiedArray4);
		}
		gluNurbsCurve (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(GLint) nknots,
			(GLfloat *) ptr2,
			(GLint) stride,
			(GLfloat *) ptr4,
			(GLint) order,
			(GLenum) type
		);

		if(knot!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  knot, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(ctlarray!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  ctlarray, ptr4, (isCopiedArray4 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluBeginSurface ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBeginSurface (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluBeginSurface (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluEndSurface ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluEndSurface (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluEndSurface (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluNurbsSurface ( GLUnurbsObj * nobj , GLint sknot_count , GLfloat * sknot , GLint tknot_count , GLfloat * tknot , GLint s_stride , GLint t_stride , GLfloat * ctlarray , GLint sorder , GLint torder , GLenum type ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluNurbsSurface (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jint sknot_count,
		jfloatArray sknot,
		jint tknot_count,
		jfloatArray tknot,
		jint s_stride,
		jint t_stride,
		jfloatArray ctlarray,
		jint sorder,
		jint torder,
		jint type)
	{
		jboolean isCopiedArray2 = JNI_FALSE;
		jfloat *ptr2 = NULL;
		jboolean isCopiedArray4 = JNI_FALSE;
		jfloat *ptr4 = NULL;
		jboolean isCopiedArray7 = JNI_FALSE;
		jfloat *ptr7 = NULL;

		if(sknot!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, sknot, &isCopiedArray2);
		}
		if(tknot!=NULL)
		{
			ptr4 = (*env)->GetFloatArrayElements(env, tknot, &isCopiedArray4);
		}
		if(ctlarray!=NULL)
		{
			ptr7 = (*env)->GetFloatArrayElements(env, ctlarray, &isCopiedArray7);
		}
		gluNurbsSurface (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(GLint) sknot_count,
			(GLfloat *) ptr2,
			(GLint) tknot_count,
			(GLfloat *) ptr4,
			(GLint) s_stride,
			(GLint) t_stride,
			(GLfloat *) ptr7,
			(GLint) sorder,
			(GLint) torder,
			(GLenum) type
		);

		if(sknot!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  sknot, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(tknot!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  tknot, ptr4, (isCopiedArray4 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(ctlarray!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  ctlarray, ptr7, (isCopiedArray7 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluBeginTrim ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBeginTrim (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluBeginTrim (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluEndTrim ( GLUnurbsObj * nobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluEndTrim (
		JNIEnv *env, jobject obj,
		jlong nobj)
	{

		gluEndTrim (
			(GLUnurbsObj *) (PointerHolder) nobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluPwlCurve ( GLUnurbsObj * nobj , GLint count , GLfloat * array , GLint stride , GLenum type ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluPwlCurve (
		JNIEnv *env, jobject obj,
		jlong nobj,
		jint count,
		jfloatArray array,
		jint stride,
		jint type)
	{
		jboolean isCopiedArray2 = JNI_FALSE;
		jfloat *ptr2 = NULL;

		if(array!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, array, &isCopiedArray2);
		}
		gluPwlCurve (
			(GLUnurbsObj *) (PointerHolder) nobj,
			(GLint) count,
			(GLfloat *) ptr2,
			(GLint) stride,
			(GLenum) type
		);

		if(array!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  array, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessBeginPolygon ( GLUtesselator * tobj , void * polygon_data ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3B (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jbyteArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jbyte *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetByteArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3S (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jshortArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jshort *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetShortArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseShortArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3I (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jintArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jint *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetIntArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3F (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jfloatArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jfloat *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetFloatArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3D (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3Z (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jbooleanArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jboolean *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetBooleanArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseBooleanArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginPolygon__J_3J (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jlongArray polygon_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jlong *ptr1 = NULL;

		if(polygon_data!=NULL)
		{
			ptr1 = (*env)->GetLongArrayElements(env, polygon_data, &isCopiedArray1);
		}
		gluTessBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj,
			(void *) ptr1
		);

		if(polygon_data!=NULL)
		{
			(*env)->ReleaseLongArrayElements(env,  polygon_data, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessBeginContour ( GLUtesselator * tobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessBeginContour (
		JNIEnv *env, jobject obj,
		jlong tobj)
	{

		gluTessBeginContour (
			(GLUtesselator *) (PointerHolder) tobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessVertex ( GLUtesselator * tobj , GLdouble coords [ 3 ] , void * vertex_data ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3B (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jbyteArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jbyte *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetByteArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseByteArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3S (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jshortArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jshort *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetShortArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseShortArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3I (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jintArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jint *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetIntArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseIntArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3F (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jfloatArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jfloat *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetFloatArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseFloatArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3D (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jdoubleArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jdouble *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetDoubleArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3Z (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jbooleanArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jboolean *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetBooleanArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseBooleanArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessVertex__J_3D_3J (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdoubleArray coords,
		jlongArray vertex_data)
	{
		jboolean isCopiedArray1 = JNI_FALSE;
		jdouble *ptr1 = NULL;
		jboolean isCopiedArray2 = JNI_FALSE;
		jlong *ptr2 = NULL;

		if(coords!=NULL)
		{
			ptr1 = (*env)->GetDoubleArrayElements(env, coords, &isCopiedArray1);
		}
		if(vertex_data!=NULL)
		{
			ptr2 = (*env)->GetLongArrayElements(env, vertex_data, &isCopiedArray2);
		}
		gluTessVertex (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble *) ptr1,
			(void *) ptr2
		);

		if(coords!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  coords, ptr1, (isCopiedArray1 == JNI_TRUE)?0:JNI_ABORT);
		}
		if(vertex_data!=NULL)
		{
			(*env)->ReleaseLongArrayElements(env,  vertex_data, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessEndContour ( GLUtesselator * tobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessEndContour (
		JNIEnv *env, jobject obj,
		jlong tobj)
	{

		gluTessEndContour (
			(GLUtesselator *) (PointerHolder) tobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessEndPolygon ( GLUtesselator * tobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessEndPolygon (
		JNIEnv *env, jobject obj,
		jlong tobj)
	{

		gluTessEndPolygon (
			(GLUtesselator *) (PointerHolder) tobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessProperty ( GLUtesselator * tobj , GLenum which , GLdouble value ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessProperty (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jint which,
		jdouble value)
	{

		gluTessProperty (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLenum) which,
			(GLdouble) value
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluTessNormal ( GLUtesselator * tobj , GLdouble x , GLdouble y , GLdouble z ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluTessNormal (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jdouble x,
		jdouble y,
		jdouble z)
	{

		gluTessNormal (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLdouble) x,
			(GLdouble) y,
			(GLdouble) z
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluGetTessProperty ( GLUtesselator * tobj , GLenum which , GLdouble * value ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluGetTessProperty (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jint which,
		jdoubleArray value)
	{
		jboolean isCopiedArray2 = JNI_FALSE;
		jdouble *ptr2 = NULL;

		if(value!=NULL)
		{
			ptr2 = (*env)->GetDoubleArrayElements(env, value, &isCopiedArray2);
		}
		gluGetTessProperty (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLenum) which,
			(GLdouble *) ptr2
		);

		if(value!=NULL)
		{
			(*env)->ReleaseDoubleArrayElements(env,  value, ptr2, (isCopiedArray2 == JNI_TRUE)?0:JNI_ABORT);
		}
	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluBeginPolygon ( GLUtesselator * tobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluBeginPolygon (
		JNIEnv *env, jobject obj,
		jlong tobj)
	{

		gluBeginPolygon (
			(GLUtesselator *) (PointerHolder) tobj
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluNextContour ( GLUtesselator * tobj , GLenum type ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluNextContour (
		JNIEnv *env, jobject obj,
		jlong tobj,
		jint type)
	{

		gluNextContour (
			(GLUtesselator *) (PointerHolder) tobj,
			(GLenum) type
		);

	}

/**
 * Original Function-Prototype :
 * <pre> 
   extern void gluEndPolygon ( GLUtesselator * tobj ) ;
 * </pre> 
 */
	JNIEXPORT void JNICALL
	Java_gl4java_GLUFuncJauJNI_gluEndPolygon (
		JNIEnv *env, jobject obj,
		jlong tobj)
	{

		gluEndPolygon (
			(GLUtesselator *) (PointerHolder) tobj
		);

	}

/* C2J Parser Version 1.5 Beta:  Java program parsed successfully. */ 
